import java.util.Random;

public class Main {

    /*
    План занятия
    1) Массивы
     */

    /*
    Теория
    Структура данных  -   способ организации данных в памяти, подразумевающий определенный алгоритм работы с собой
    Алгоритм - последовательность действий
    Массив - структура данных, которая хранит данные в сплошной области памяти(по аналогии с лесным или жилым массивом)
    Массивы позволяют получать доступ к своим элементам по индексу, таким образом зная адрес начала массива достаточно
    просто прибавить к нему количество индексов, умноженное на размер элемента массива, чтобы вычислить адрес требуемого
    элемента.
    Недостаток массивов - необходимость соблюдения сплошной области в памяти, таким образом для вставки и удаления элементов
    приходится выполнять большое количество операций

    Чтобы объявить массив в Java нужно указать его тип, присвоить ему имя и выделить для него память:
     Указываю тип   Переменная       Выделяю память
         int[]        arr         =    new int[10];

         Доступ к элементу массива можно получить по его индексу:
         имя массива  индекс  присваиваем значение
         arr           [1] = 10;
         length - метод, который возвращаем размер массива

        Оценивая сложность алгоритма, уместно делать приблизительные расчеты
        Количество шагов для линейного поиска(все возможные варианты)
        1 2                                                                  (n-1)   n
        n/2  шагов в среднем требуется, чтобы найти искомое значение

        Бинарный поиск подразумевает поиск в упорядоченной структуре, идея заключается в делении структуры на 2 части и
        сравнении иского значения с серединой диапазона, если число больше середины диапазона отбрасывается левая часть,
        если меньше правая, таким образом при каждой проверке получается сократить количество проверяемых элементов в 2 раза
     */

    /*
    Заметки
    Структура данных всегда подразумевает алгоритм
    Алгоритмы не всегда нуждаются в специальных структурах данных

    Локальная переменная определена в методе и видна только в нем, глобальная определена в классе и видна в нем или даже
    за его пределами в зависимости от модификатора доступа

    Инкапсуляция - погружение в класс, как правило инкапсуляция подразумевает разработку уровня доступа к данным

    Рассуждая о решение задачи, попробуйте представить, что данные в этой задачи упорядочены.

     */

    static int[] arr = new int[10];     // Декларация массива

    static Random random = new Random(); // Генератор ПСЕВДОслучайных чисел

    public static void main(String[] args) {

        for (int i = 0; i < arr.length; i++) {       // Вывожу массив до инициализации
             System.out.print(arr[i] + " ");
        }

        System.out.println();

        for (int i = 0; i < arr.length; i++){
            arr[i] = random.nextInt(10);       // Инициализирую массив псевдослучаными числами в диапазоне до 10
            System.out.print(arr[i] + " ");
        }

        System.out.println();


        LowArray lowArray = new LowArray(100);   // Создать объект, в котором будет массив на 100 элементов

        lowArray.setElem(0, 77);         // Добавляем элементы в массив
        lowArray.setElem(1, 15);
        lowArray.setElem(2, 58);
        lowArray.setElem(3, 23);
        lowArray.setElem(4, 87);
        lowArray.setElem(5, 12);

        System.out.println(lowArray.getElem(5));  // Получаем элементы массива
        System.out.println(lowArray.getElem(20));
       // System.out.println(lowArray.getElem(101));  Обратились к элементу за шраницей массива

        HighArray highArray = new HighArray(10);

        highArray.insert(10);
        highArray.insert(21);
        highArray.insert(34);
        highArray.insert(54);
        highArray.insert(85);

        highArray.display();

        System.out.println(highArray.find(85));

        highArray.delete(54);

        highArray.display();

        highArray.sort();

        highArray.display();
        highArray.insert(34);
        highArray.insert(54);
        highArray.insert(85);
        highArray.insert(35);
        highArray.insert(56);
        highArray.display();

        System.out.println(highArray.findIndex(85));
        System.out.println(highArray.findIndex(134));

         int a = 534671;

        for (int i = 0; i < 1000000; i++) {
            System.out.println("Итерация: "+ i);
                if(a == i){
                    System.out.println("Нашли");
                    break;
                }

        }


        int min = 0;                        //Указываем минимальное, максимальное и целевое значение
        int max = 999999;
        int target = 534671;
        int count = 0;                     // Устанавливаем счетчик итераций цикла


        while (min <= max){              //  Начинаем цикл
            count++;                      // Увеличиваем счетчик
            int mid = (min + max)/2;      // Находим середину

            if(target < mid){            // Если значение меньше середины
                max = mid-1;
            }
            else if(target > mid) {     // Если значение больше середины
                min = mid + 1;
            }
            else {                        // Значение найдено. Выводи решение и счетчик
                System.out.println("Искомое значение: " + mid);
                System.out.println("Количество шагов: " + count);
                break;                    // Выходим из цикла
            }
        }








    }
}
